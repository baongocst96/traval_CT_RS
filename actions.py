# -*- coding: utf-8 -*-
from typing import Dict, Text, Any, List, Union, Optional
from rasa_sdk import Tracker, Action
from rasa_sdk.events import SlotSet, UserUttered,UserUtteranceReverted
from rasa_sdk.forms import FormAction
from rasa_sdk.executor import CollectingDispatcher
import json, datetime, yaml, re
from rasa_sdk.events import SlotSet, Restarted, AllSlotsReset
import sqlite3, logging
from rasa_sdk.interfaces import ActionExecutionRejection
from deepai_nlp.utils import remove_tone_line
from rasa_sdk.events import ReminderScheduled, Form
from  custom_form import DulichForm
 
logger = logging.getLogger(__name__)
REQUESTED_SLOT = "requested_slot"
BUTTON_HOTTEL = []
def find_action_lastest(tracker):
    for event in reversed(tracker.events):
        try:
            if event.get('name') not in [ 'action_listen', None, 'utter_ask_continue' ] :
                return event.get('name')
            else:
                print("current action name is", event.get('name'))
        except:
            pass
    return 'error'

class TypeText(Action):
    def name(self) -> Text:
        return "typetext"
    def run(
        self, 
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
        ) -> List[Dict]:
        actionlastest = find_action_lastest(tracker)
        if actionlastest == 'action_find_hottel':
            print("phia truoc la action find_hottel")
            return UserUttered("/greet",intent={'name': 'greet', 'confidence': 1.0})


class ViTri(Action):
    def name(self) -> Text:
        return "action_traval_detail"

    def forrmat_payload(self, key, value):
        enti = {key:value.lower()}
        return json.dumps(enti)

    def list_button(self, thong_tin):
        buttons = []
        buttons.append({
            "title":"üîçüîç th√¥ng tin "+thong_tin,
            "payload":"/request_thongtin{}".format(self.forrmat_payload("thong_tin", thong_tin))
            })
        buttons.append({
            "title":"üöó ƒë·ªãa ch·ªâ "+thong_tin,
            "payload" : "/request_vitri{}".format(self.forrmat_payload("vi_tri", thong_tin))
            })
        buttons.append({
            "title":"üèÑüèæ‚Äç‚ôÇÔ∏èüèÑüèæ‚Äç‚ôÇÔ∏è ch∆°i g√¨ ·ªü "+thong_tin,
            "payload":"/request_hoatdong{}".format(self.forrmat_payload("hoat_dong", thong_tin))
            })
        buttons.append({
            "title":"üè¶üè¶ chi ph√≠ ·ªü "+thong_tin,
            "payload":"/request_chiphi{}".format(self.forrmat_payload("chi_phi", thong_tin))
            })
        buttons.append({
            "title":"üèûüèû kh√°m ph√° ƒë·ªãa ƒëi·ªÉm kh√°c",
            "payload":"/request_chung"
            })

        return buttons

    def run(
        self, 
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
        ) -> List[Dict]:
        
        dict_intent = {
        "request_vitri": "vi_tri",
        "request_thongtin": "thong_tin",
        "request_hoatdong": "hoat_dong",
        "request_chiphi": "chi_phi"
        }
        dict_thongtinct = {
        "b·∫øn ninh ki·ªÅu":{
            "thong_tin": "Theo Wiki: B·∫øn Ninh Ki·ªÅu l√† m·ªôt ƒë·ªãa danh du l·ªãch c√≥ t·ª´ l√¢u v√† h·∫•p d·∫´n du kh√°ch b·ªüi phong c·∫£nh s√¥ng n∆∞·ªõc h·ªØu t√¨nh v√† v·ªã tr√≠ thu·∫≠n l·ª£i nh√¨n ra d√≤ng s√¥ng H·∫≠u. T·ª´ l√¢u b·∫øn Ninh Ki·ªÅu ƒë√£ tr·ªü th√†nh bi·ªÉu t∆∞·ª£ng v·ªÅ n√©t ƒë·∫πp th∆° m·ªông b√™n b·ªù s√¥ng H·∫≠u c·ªßa c·∫£ Th√†nh ph·ªë C·∫ßn Th∆°, thu h√∫t nhi·ªÅu du kh√°ch ƒë·∫øn tham quan v√† ƒëi v√†o th∆° ca.",
            "hoat_dong": "ƒÇn u·ªëng, ch·ª•p h√¨nh, ƒëi d·∫°o",
            "chi_phi": "kh√¥ng c√≥ v√© v√†o c·ªïng, ƒë·ªì ƒÉn gi√° c·∫£ h·ª£p l√Ω ",
            "img":"https://i.ibb.co/TWnF0nn/ben-ninh-kieu.jpg",
            "vi_tri":"N·∫±m ·ªü: 38 Hai B√† Tr∆∞ng, ‚Äã‚ÄãT√¢n An, Ninh Ki·ªÅu, C·∫ßn Th∆° \n B·∫°n c√≥ th·ªÉ di chuy·ªÉn b·∫±ng √¥ t√¥ ho·∫∑c xe m√°y ƒë√©n ƒë√≥"
            },
        "ch·ª£ ƒë√™m":{
            "thong_tin": "·ªû ƒë√¢y c√≥ b√°n r·∫•t nhi·ªÅu m√≥n ngon, trong ƒë√≥ c√≥ nh·ªØng m√≥n ƒë·∫∑c tr∆∞ng c·ªßa mi·ªÅn T√¢y m√† ti√™u bi·ªÉu l√† nh·ªØng m√≥n ch√®",
            "hoat_dong": "ƒÇn u·ªëng, ch·ª•p h√¨nh, ƒëi d·∫°o, shopping",
            "chi_phi": "kh√¥ng c√≥ v√© v√†o c·ªïng, ƒë·ªì ƒÉn ngon, qu·∫ßn √°o gi√° c·∫£ h·ª£p l√Ω",
            "img":"https://i.ibb.co/kSntHQB/cho-dem.png",
            "vi_tri":"N·∫±m ·ªü: Hai B√† Tr∆∞ng, T√¢n An, Ninh Ki·ªÅu, C·∫ßn Th∆°, Vi·ªát Nam \n B·∫°n c√≥ th·ªÉ di chuy·ªÉn b·∫±ng √¥ t√¥ ho·∫∑c xe m√°y ƒë√©n ƒë√≥" 
            },
        "nh√† c·ªï b√¨nh th·ªßy":{
            "thong_tin": "B·∫±ng gi√° tr·ªã ki·∫øn tr√∫c, l·ªãch s·ª≠ c·ªßa m√¨nh, nh√† c·ªï B√¨nh Th·ªßy ƒë√£ ƒë∆∞·ª£c c√¥ng nh·∫≠n l√† ‚Äúdi t√≠ch ngh·ªá thu·∫≠t c·∫•p qu·ªëc gia‚Äù, ng√†y c√†ng thu h√∫t nhi·ªÅu kh√°ch ƒë·∫øn thƒÉm c≈©ng nh∆∞ c√°c ƒëo√†n l√†m phim v·ªÅ m∆∞·ª£n b·ªëi c·∫£nh cho nh·ªØng th∆∞·ªõc phim c·ªßa m√¨nh.",
            "hoat_dong": "tham quan , ch·ª•p ·∫£nh",
            "chi_phi": "kh√¥ng c√≥ v√© v√†o c·ªïng",
            "img":"https://i.ibb.co/2szXWhJ/nha-co-binh-thuy.jpg",
            "vi_tri":"N·∫±m ·ªü: 144 B√πi H·ªØu Nghƒ©a, B√¨nh Thu·ª∑, B√¨nh Th·ªßy, C·∫ßn Th∆°, Vi·ªát Nam \n\ B·∫°n c√≥ th·ªÉ di chuy·ªÉn b·∫±ng √¥ t√¥ ho·∫∑c xe m√°y ƒë√©n ƒë√≥"
            },
        "v∆∞·ªùn c√¢y m·ªπ kh√°nh":{
            "thong_tin": "ƒê·∫∑t ch√¢n t·ªõi v∆∞·ªùn tr√°i c√¢y n√†y th√¨ b·∫°n s·∫Ω ƒë∆∞·ª£c tham quan h∆°n 20 gi·ªëng c√¢y tr·ªìng kh√°c nhau s·∫Ω cho b·∫°n m·ªôt tr·∫£i nghi·ªám ƒë·∫∑c bi·ªát.",
            "hoat_dong": "tham quan , ch·ª•p ·∫£nh, h√°i tr√°i c√¢y t·∫°i v∆∞·ªùn v√† c√°c tr√≤ ch∆°i d√¢n gian h·∫•p d·∫´n",
            "chi_phi": "v√© v√†o c·ªïng 20k/ng, h√°i tr√°i c√¢y ƒÉn t·∫°i v∆∞·ªùn, mang v·ªÅ t√≠nh theo gi√° c·ªßa v∆∞·ªùn",
            "img":"https://i.ibb.co/gRV11df/my-khanh.jpg",
            "vi_tri":"N·∫±m ·ªü: M·ªπ Kh√°nh, Phong ƒêi·ªÅn, C·∫ßn Th∆°, Vi·ªát Nam \n B·∫°n c√≥ th·ªÉ di chuy·ªÉn b·∫±ng √¥ t√¥ ho·∫∑c xe m√°y ƒë√©n ƒë√≥"
            },
        "ch·ª£ n·ªïi c√°i rƒÉng":{
            "thong_tin": "Theo Wiki: Ch·ª£ n·ªïi C√°i RƒÉng l√† ch·ª£ n·ªïi chuy√™n trao ƒë·ªïi, mua b√°n n√¥ng s·∫£n, c√°c lo·∫°i tr√°i c√¢y, h√†ng h√≥a, th·ª±c ph·∫©m, ƒÉn u·ªëng ·ªü tr√™n s√¥ng v√† l√† ƒëi·ªÉm tham quan ƒë·∫∑c s·∫Øc c·ªßa qu·∫≠n C√°i RƒÉng, th√†nh ph·ªë C·∫ßn Th∆°",
            "hoat_dong": "tham quan , ch·ª•p ·∫£nh, ƒëi thuy·ªÅn tham quan ch·ª£ n·ªïi",
            "chi_phi": "v√© tham quan b·∫±ng thuy√™n 200k/ng",
            "img":"https://i.ibb.co/Xsy46sH/cho-noi-cai-rang.jpg",
            "vi_tri":"N·∫±m ·ªü: 46 Hai B√† Tr∆∞ng, L√™ B√¨nh, C√°i RƒÉng, C·∫ßn Th∆° \n B·∫°n c√≥ th·ªÉ di chuy·ªÉn b·∫±ng √¥ t√¥ ho·∫∑c xe m√°y ƒë·∫øn b·∫øn t√†u dau ƒë√≥ thu√™ thuy·ªÅn ƒë·ªÉ tham quan tr·ª£ n·ªïi"
            }

        }
        if  tracker.latest_message['intent'].get('name') == 'request_chung':
            intro = "ƒê·∫øn t·ªõi C·∫ßn Th∆° th√¨ b·∫°n kh√¥ng th·ªÉ b·ªè qua c√°c ƒë·ªãa ƒëi·ªÉm nh∆∞ B·∫øn Ninh Ki·ªÅu, Ch√πa √îng, Ch·ª£ ƒê√™m, nh√† c·ªï B√¨nh Th·ªßy, V∆∞·ªùn c√¢y M·ªπ Kh√°nh, Thi·ªÅn Vi·ªán Tr√∫c L√¢m"
            buttons=[]
            for keys, text in dict_thongtinct.items():
                buttons.append({
                    "title":keys,
                    "payload": "/request_thongtin{}".format(self.forrmat_payload("thong_tin", keys))
                    })
            dictmes = tracker.latest_message
            mes = dictmes['text']
            conn = sqlite3.connect('/media/baongocst/Free/sqlite3/chatbot_dulich.db')
            c = conn.cursor()
            sql = "insert into chatbot(questions) values('%s')"%mes
            print(sql)
            c.execute(sql)
            conn.commit()
            conn.close()
            dispatcher.utter_button_message(intro, buttons=buttons)
        else:
            intent_name = tracker.latest_message['intent'].get('name')
            try:
                slot_name = dict_intent[intent_name]
                thong_tin = next(tracker.get_latest_entity_values(slot_name), None)
                print("Thong tin ", thong_tin)
                # thong_tin = tracker.get_slot(slot_name)
                thong_tin = thong_tin.replace('_',' ')
            except:
                print("error false intent")
                return[]

            thong_tin = next(tracker.get_latest_entity_values(slot_name), None)
            print("Thong tin ", thong_tin)
            # thong_tin = tracker.get_slot(slot_name)
            thong_tin = thong_tin.replace('_',' ')
            ask = dict_thongtinct[thong_tin][slot_name]
            buttons = self.list_button(thong_tin)
            if(intent_name == 'request_thongtin'):  
                dispatcher.utter_media(dict_thongtinct[thong_tin]['img'])
            dispatcher.utter_button_message(ask,buttons=buttons)

        
        return []

        ##if any(tracker.get_latest_entity_values("CT"))

# find hottel 
# sear hottel with location and quality
# show infor hottel, view price, price, adress 
# => form book room

class find_hottel(Action):
    def name(self) -> Text:
        return "action_find_hottel"

    dict_listhottel = {
        "khach san TTC":
            {
            "name_hottel":"khach san TTC",
            "lc_hottel":"qu·∫≠n ninh ki·ªÅu",
            "qu_hottel":"kh√°ch s·∫°n ch·∫•t l∆∞·ª£ng",
            "img_hottel":"https://i.ibb.co/4gLN0PC/ttc-hottel.jpg",
            "adress_Hottel":"312/2 B·∫øn Ninh ki·ªÅu th√†nh ph·ªë c·∫ßn th∆°",
            "detail": "kh√°ch s·∫°n s·∫°ch s·∫ª tho√°ng m√°t ƒë√™m 500k",
            "price":"500"
            },
        "khach san T√¢y Nam":
            {
            "name_hottel":"khach san T√¢y Nam",
            "lc_hottel":"qu·∫≠n c√°i rƒÉng",
            "qu_hottel":"kh√°ch s·∫°n ch·∫•t l∆∞·ª£ng",
            "img_hottel":"https://i.ibb.co/GnSXWT2/taynam-hottel.jpg",
            "adress_Hottel":"312/2 c√¢√π quang trung th√†nh ph·ªë c·∫ßn th∆°",
            "detail": "kh√°ch s·∫°n s·∫°ch s·∫ª tho√°ng m√°t ƒë√™m 300k",
            "price":"300"
            }
        }

    menu_show = {
        "name_hottel":"T√™n kh√°ch s·∫°n",
        "lc_hottel":"Khu v·ª±c",
        "qu_hottel":"Lo·∫°i kh√°ch s·∫°n",
        "adress_Hottel":"ƒê·ªãa ch·ªâ",
        "detail":"Th√¥ng tin chung",
        "price":"T·∫ßm Gi√°"
        }

    def forrmat_payload(self, enti):
        return json.dumps(enti)

    def run(
        self, 
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
        ) -> List[Dict]:      
        #test phan button
        print(tracker.get_latest_input_channel())
        print("phia truoc la action find_hottel", tracker.latest_message, type(tracker.latest_message))
        intent={'name':'greet','confidence':1.0}
        return [UserUtteranceReverted(),UserUttered("/happy", {
                         "intent": {"confidence": 2.217, "name": "happy"}, 
                         "entities": []
                        }), SlotSet('lc_hottel', 'lc_hottel')]
        try:
            actionlastest = find_action_lastest(tracker)
            print('*****************', actionlastest)
            if actionlastest == 'action_find_hottel':
                print("phia truoc la action find_hottel", actionlastest)
                return [UserUttered("kh√¥ng hi·ªÉu g√¨ lu√¥n ·∫πc ")]
        except:
            print("erro except UserUttered")
            pass            
        if  tracker.latest_message['intent'].get('name') == 'request_hottel':
            if any(tracker.get_latest_entity_values("lc_hottel")):
                lc_hottel = next(tracker.get_latest_entity_values("lc_hottel"), None)  ## value entity 
            else:
                intro = "D∆∞·ªõi ƒë√¢y l√† m·ªôt v√†i g·ª£i √Ω ph√π h·ª£p cho b·∫°n:"				
                buttons = []
                for keys, text in self.dict_listhottel.items():					
                    buttons.append({
                        "title":keys,
                        "payload": "/info_hottel{}".format(self.forrmat_payload({"name_hottel": self.dict_listhottel[keys]['name_hottel']}))
                        })
                dispatcher.utter_button_message(intro,buttons=buttons)  
        if tracker.latest_message['intent'].get('name') == 'info_hottel':
            info = self.dict_listhottel[next(tracker.get_latest_entity_values("name_hottel"), None)]
            detail = ''
            for key, text in info.items():
                if(key != 'img_hottel'):
                    detail += str(self.menu_show[key]) + ' : ' + text + '\n\n\n' 
            dispatcher.utter_media(info['img_hottel'])
            bt_datphong = []
            bt_datphong.append({
                "title":"ƒê·∫∑t ph√≤ng",
                "payload":"/form_hottel{}".format(self.forrmat_payload({'lc_hottel':info['lc_hottel'], 'qu_hottel':info['qu_hottel']}))
                })
            bt_datphong.append({
                "title":"ch·ªçn kh√°ch s·∫°n kh√°c",
                "payload":"/request_hottel"
                })
            for event in reversed(tracker.events):
                print("current action name is", event.get('name'))
            if tracker.latest_message.get('text').lower() == 'ccc':
                print("da xet vao in tent")
                return UserUttered("/greet",intent={'name': 'greet', 'confidence': 1.0})
            BUTTON_HOTTEL = bt_datphong
            dispatcher.utter_button_message(detail,buttons=bt_datphong)

# form book hottel 
# request numberroom, time, sdt
# show kq
class HottelForm(DulichForm):
    """Example of a custom form action"""

    def name(self) -> Text:
        """Unique identifier of the form"""

        return "hottel_form"

    @staticmethod
    def required_slots(tracker: Tracker) -> List[Text]:
        """A list of required slots that the form has to fill"""

        return ["name_hottel","num_room", "time", "sdt", "note_hottel"]

    def slot_mappings(self) -> Dict[Text, Union[Dict, List[Dict]]]:
        """A dictionary to map required slots to
            - an extracted entity
            - intent: value pairs
            - a whole message
            or a list of them, where a first match will be picked"""

        return {
            "time": [
            self.from_entity(entity="time"),
            self.from_text()
            ],
            "num_room":  [
            self.from_entity(entity="num_room"),
            self.from_text()
            ],					  
            "sdt": self.from_text(),
            "name_hottel":[
            self.from_entity(entity="name_hottel"),
            self.from_text()
            ],
            "note_hottel": self.from_text()		   
            
        }

    def forrmat_payload(self, enti):
        return json.dumps(enti)

    # USED FOR DOCS: do not rename without updating in docs
    @staticmethod
    def is_int(string: Text) -> bool:
        """Check if a string is an integer"""

        try:
            int(string)
            return True
        except ValueError:
            return False

    def validate_sdt(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> Optional[Text]:
        
        import re

        pattern = "^(0)[0-9]{9}"
        z = re.match(pattern, value)
    
        if z and len(value) == 10:
            return {"sdt": value}
        else:
            dispatcher.utter_template("utter_wrong_phone", tracker)
            return {"sdt": None}

    def validate_num_room(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> Optional[Text]:
        if any(tracker.get_latest_entity_values("num_room")):
            return {"num_room": value}
        if self.is_int(value) and int(value) > 0:
            return {"num_room": value}
        else:
            dispatcher.utter_template("utter_wrong_num_room", tracker)
            return {"num_room": None}
    
    def show_date(self,n):
        day = datetime.datetime.today() + datetime.timedelta(days=1)
        return day.strftime ('%d-%m-%Y')

    def validate_time(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> Optional[Text]:
        try:
            if any(tracker.get_latest_entity_values("time")) or any(tracker.get_slot("time")):
                switcher = {
                    'ng√†y_mai':self.show_date(1),
                    'ng√†y_kia':self.show_date(2),
                    'h√¥m_nay':self.show_date(0)
                }
                value = switcher.get(value, value)
                return {"time": value}
        except:
            wrong_time = "!!!ü•¥ H√£y nh·∫≠p th·ªùi gian c·ª• th·ªÉ: \n\n\n Ex: ng√†y mai, ng√†y kia, ng√†y 09/01,..."
            
            dispatcher.utter_message(wrong_time)
            return {"time": None}
        else:
            wrong_time = "!!!ü•¥ H√£y nh·∫≠p th·ªùi gian c·ª• th·ªÉ: \n\n\n Ex: ng√†y mai, ng√†y kia, ng√†y 09/01,..."
            
            dispatcher.utter_message(wrong_time)
            return {"time": None}

       
    def submit(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> List[Dict]:
        """Define what the form has to do
            after all required slots are filled"""

        # utter submit template
        info={
        "name_hottel":tracker.get_slot('name_hottel'),
        "num_room":tracker.get_slot('num_room'),
        "sdt":tracker.get_slot('sdt'),
        "time":tracker.get_slot('time'),
        "note_hottel":tracker.get_slot('note_hottel')
        }
        text_info = ''
        for key, text in info.items():
            text_info += str(key) + ' : ' + str(text) + '\n\n\n'
        buttons= [{
            "title":"ƒê·ªìng √Ω",
            "payload":"/agreehottel"
            },
            {
            "title":"Ch·ªçn kh√°ch s·∫°n kh√°c",
            "payload":"/request_hottel"
            },
            {
            "title":"Thay ƒë·ªïi thong tin",
            "payload":"/request_editHottel"
            }]
        dispatcher.utter_button_message(text_info, buttons=buttons)
        return []

## change info hottel
# chose info to change 
# chang info to utter done 

class Restart_hottel(Action):
    def name(self) -> Text:
        return "restart_form_hottel"
    def run(
        self, 
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
        ) -> List[Dict]:
        return[
            SlotSet("sdt", None),
            SlotSet("num_room", None),
            SlotSet("time", None),
            SlotSet("note_hottel", None)
        ]
        
## restaurant

class FindRestaurantToBook(Action):
    def name(self) -> Text:
        return "action_find_res_to_book"

    @staticmethod
    def db_name() -> Dict[Text, Any]:
        return {
            "ChIJeS6zcfuvCjERtN0GaPDQoBw": "Nh√† h√†ng Ng·ªçc Gia Trang",
            "ChIJMyTxJeqvCjERoiAEm1aMnLA": "Nh√† h√†ng S√¥ng Ti·ªÅn",
            "ChIJx6-nJPavCjERfip2XNPNxoQ": "Nh√† h√†ng h·∫£i s·∫£n Ph·ªë Bi·ªÉn",
            "ChIJdT4xNPCvCjERii0h_4iJHzQ": "Qu√°n ƒÉn L·ªôc Ph·ªë",
            "ChIJL0S5MamlCjERoxY9U1uAF9c": "Nh√† h√†ng Mekong Taste",
            "ChIJF-i2aXalCjERI2uZb6b-8kQ": "Nh√† h√†ng Th·ªõi S∆°n",
            "ChIJYXKWUaq6CjERMMh5EG--xJk": "Nh√† h√†ng Trung L∆∞∆°ng",
            "ChIJh36_ePuvCjERsrcMdlZzHGw": "Nh√† h√†ng L√†ng Vi·ªát",
            "ChIJ4-jigfKvCjERyEH2_BC_7u8": "Nh√† h√†ng Ch∆∞∆°ng D∆∞∆°ng",
            "ChIJp_0PMsOvCjERxoWVnQ1-Ils": "Qu√°n ƒÉn T·∫° Hi·ªÅn",
            "ChIJb5rGx_CvCjERceuwJqes_Ls": "Nh√† h√†ng M·ªπ Ph√∫c",
            "ChIJu6cpKPqvCjER3FGV3WyOXhA": "Qu√°n ƒÉn ƒê·ªìng Nam",
            "ChIJ9QteN-qvCjERkf2Owo0MXG4": "Nh√† h√†ng Qu√™ H∆∞∆°ng"
        }
    def forrmat_payload(self, enti):
        return json.dumps(enti)

    def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any]
        ) -> List[Dict]:

        # retrieve google api key		
        with open("./ga_credentials.yml", 'r') as ymlfile:
            cfg = yaml.safe_load(ymlfile)
        key = cfg['credentials']['GOOGLE_KEY']

        '''
        # get user's current location		
        get_origin = requests.post(
            "https://www.googleapis.com/geolocation/v1/geolocate?key={}".format(key)).json()
        
        origin_lat = get_origin['location']['lat']
        origin_lng = get_origin['location']['lng']
        '''
        # info = []

        # for i in self.db_name().keys():
        #	 place = requests.get('https://maps.googleapis.com/maps/api/distancematrix/json?origins=place_id:{}&destinations=place_id:{}&language={}&key={}'
        #					 .format("ChIJUx33J-uvCjERcVVUDPqhLak", i, "vi", key)).json()
        #	 info.append({
        #		 "name": self.db_name()[i],
        #		 "distance_text": place['rows'][0]['elements'][0]['distance']['text'],
        #		 "distance_value": place['rows'][0]['elements'][0]['distance']['value'],
        #		 "duration": place['rows'][0]['elements'][0]['duration']['text']
        #		 })

        info = [
            {
                'name': 'Nh√† h√†ng S√¥ng Ti·ªÅn', 
                'distance_text': '4,5 km', 
                'distance_value': 4511, 
                'duration': '10 ph√∫t',
                'image_res':'https://i.ibb.co/M84HxVj/res.jpg',
                'menu_res':'https://i.ibb.co/k30xHBs/menu.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng Qu√™ H∆∞∆°ng', 
                'distance_text': '4,6 km', 
                'distance_value': 4587, 
                'duration': '10 ph√∫t',
                'image_res':'https://i.ibb.co/GcgT4ct/res1.jpg',
                'menu_res':'https://i.ibb.co/gZc4H5q/menu2.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng Ch∆∞∆°ng D∆∞∆°ng', 
                'distance_text': '4,7 km', 
                'distance_value': 4690, 
                'duration': '11 ph√∫t',
                'image_res':'https://i.ibb.co/7zwrg3j/res2.jpg',
                'menu_res':'https://i.ibb.co/xMDr6Wg/menu3.jpg'
            }, 
            {
                'name': 'Qu√°n ƒÉn T·∫° Hi·ªÅn', 
                'distance_text': '4,7 km', 
                'distance_value': 4715, 
                'duration': '9 ph√∫t',
                'image_res':'https://i.ibb.co/4wbDhwt/res3.jpg',
                'menu_res':'https://i.ibb.co/VLY6v1x/menu2.jpg'
            }, 
            {
                'name': 'Qu√°n ƒÉn L·ªôc Ph·ªë', 
                'distance_text': '5,8 km', 
                'distance_value': 5813, 
                'duration': '14 ph√∫t',
                'image_res':'https://i.ibb.co/M84HxVj/res.jpg',
                'menu_res':'https://i.ibb.co/k30xHBs/menu.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng M·ªπ Ph√∫c', 
                'distance_text': '6,1 km', 
                'distance_value': 6121, 
                'duration': '14 ph√∫t',
                'image_res':'https://i.ibb.co/GcgT4ct/res1.jpg',
                'menu_res':'https://i.ibb.co/VLY6v1x/menu2.jpg'
            }, 
            {
                'name': 'Qu√°n ƒÉn ƒê·ªìng Nam', 
                'distance_text': '6,7 km', 
                'distance_value': 6694, 
                'duration': '15 ph√∫t',
                'image_res':'https://i.ibb.co/7zwrg3j/res2.jpg',
                'menu_res':'https://i.ibb.co/gZc4H5q/menu2.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng h·∫£i s·∫£n Ph·ªë Bi·ªÉn', 
                'distance_text': '7,0 km', 
                'distance_value': 6972, 
                'duration': '16 ph√∫t',
                'image_res':'https://i.ibb.co/4wbDhwt/res3.jpg',
                'menu_res':'https://i.ibb.co/xMDr6Wg/menu3.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng L√†ng Vi·ªát', 
                'distance_text': '7,5 km', 
                'distance_value': 7461, 
                'duration': '15 ph√∫t',
                'image_res':'https://i.ibb.co/M84HxVj/res.jpg',
                'menu_res':'https://i.ibb.co/k30xHBs/menu.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng Ng·ªçc Gia Trang', 
                'distance_text': '7,5 km', 
                'distance_value': 7503, 
                'duration': '15 ph√∫t',
                'image_res':'https://i.ibb.co/GcgT4ct/res1.jpg',
                'menu_res':'https://i.ibb.co/VLY6v1x/menu2.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng Trung L∆∞∆°ng', 
                'distance_text': '9,9 km', 
                'distance_value': 9922, 
                'duration': '17 ph√∫t',
                'image_res':'https://i.ibb.co/7zwrg3j/res2.jpg',
                'menu_res':'https://i.ibb.co/gZc4H5q/menu2.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng Th·ªõi S∆°n', 
                'distance_text': '12,2 km', 
                'distance_value': 12156, 
                'duration': '25 ph√∫t',
                'image_res':'https://i.ibb.co/4wbDhwt/res3.jpg',
                'menu_res':'https://i.ibb.co/xMDr6Wg/menu3.jpg'
            }, 
            {
                'name': 'Nh√† h√†ng Mekong Taste', 
                'distance_text': '12,4 km', 
                'distance_value': 12363, 
                'duration': '27 ph√∫t',
                'image_res':'https://i.ibb.co/M84HxVj/res.jpg',
                'menu_res':'https://i.ibb.co/k30xHBs/menu.jpg'
            }]

        info.sort(key=lambda x: x['distance_value'])

        msg  = "D∆∞·ªõi ƒë√¢y l√† th√¥ng tin nh√† h√†ng g·∫ßn nh·∫•t Bot c√≥ th·ªÉ gi√∫p b·∫°n ƒë·∫∑t b√†n n√®..."
        dispatcher.utter_message(msg)

        buttons = []
        msg_title = "üîñ T√™n: {}\n\
                    \nüóæ Kho·∫£ng c√°ch: {}\n\
                    \n‚åõ Th·ªùi gian ƒë·∫øn n∆°i ∆∞·ªõc t√≠nh: {}".format(info[0]['name'], info[0]['distance_text'], info[0]['duration'])
        enti = {"name_res":"{}".format(info[0]['name'].lower())}
        print(enti)
        enti_json = json.dumps(enti)
        buttons.append({
            "title": "üëÄ xem chi ti·∫øt",
            "payload": "/detail_res{}".format(enti_json)
            })
        # buttons.append({
        #	 "title": "üö∏ Ch·ªâ ƒë∆∞·ªùng",
        #	 "payload": "/direct_place_res{}".format(enti_json)
        #	 })
        buttons.append({
            "title": "‚ûï More",
            "payload": "/more_res"
            })
        dispatcher.utter_button_message(msg_title, buttons=buttons)
        return [SlotSet("lst_res", info)]

class MoreRestaurantBook(Action):
    def name(self):
        return "action_more_book"

    def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any]
        ) -> List[Dict]:

        result = tracker.get_slot("lst_res")

        msg = "Th√™m 3 nh√† h√†ng n·ªØa cho b·∫°n ch·ªçn n√®...üòç"
        dispatcher.utter_message(msg)

        msg_title = "T√¥i c√≥ th·ªÉ l√†m g√¨?"
        buttons = []
        for i in [1, 2, 3]:
            msg_in = "üîñ T√™n: {}\n\
                    \nüóæ Kho·∫£ng c√°ch: {}\n\
                    \n‚åõ Th·ªùi gian ƒë·∫øn n∆°i ∆∞·ªõc t√≠nh: {}".format(result[i]['name'], result[i]['distance_text'], result[i]['duration'])
            dispatcher.utter_message(msg_in)

            enti = {"name_res":result[i]['name'].lower()}
            enti_json = json.dumps(enti)
            buttons.append({
                "title":"{}".format(result[i]['name']),
                "payload":"/detail_res{}".format(enti_json)
                })

        buttons.append({
            "title":"ü§î B·∫°n c√≥ th·ªÉ l√†m g√¨?",
            "payload":"/what_can_help"
            })

        dispatcher.utter_button_message(msg_title, buttons=buttons)
        return []
class detailRestaurant(Action):
    def name(self):
        return "action_detail_res"
        
    def forrmat_payload(self, enti):
        return json.dumps(enti)
    
    def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any]
        ) -> List[Dict]:
        nameres = tracker.get_slot('name_res')
        result = tracker.get_slot("lst_res")
        info = []
        for i in result:
            if(i['name'].lower() == nameres):
                info = i
                break
        msg_in = "üîñ T√™n: {}\n\
                    \nüóæ Kho·∫£ng c√°ch: {}\n\
                    \n‚åõ Th·ªùi gian ƒë·∫øn n∆°i ∆∞·ªõc t√≠nh: {}".format(info['name'], info['distance_text'], info['duration'])
        dispatcher.utter_media(info['image_res'])
        dispatcher.utter_media(info['menu_res'])
        buttons = []
        buttons.append({
            "title": "üè∑ ƒê·∫∑t b√†n",
            "payload": "/book_restaurant{}".format(self.forrmat_payload({"name_res":info['name']}))
            })
        buttons.append({
            "title":"Back",
            "payload":"/more_res"
        })
        dispatcher.utter_button_message(msg_in, buttons=buttons)
        
    # Book form
class RestaurantForm(FormAction):

    def name(self) -> Text:
        return "restaurant_form"

    @staticmethod
    def required_slots(tracker: Tracker) -> List[Text]:
        # if any(tracker.get_slot("time")):
        #     SlotSet("time", tracker.get_slot("time"))
        return ["num_people_res", "add_request_res", "phone_res", "time"]

    def slot_mappings(self) -> Dict[Text, Union[Dict, List[Dict]]]:

        return {
            "num_people_res": [
                self.from_entity(entity="num_people_res"),
                self.from_text(),
            ],
            "add_request_res": [
                self.from_text()
            ],
            "phone_res": self.from_text(),
            "time":[
                self.from_text(),
                self.from_entity(entity="time")
            ]
        }

    @staticmethod
    def is_int(string: Text) -> bool:

        try:
            int(string)
            return True
        except ValueError:
            return False
    def show_date(self,n):
        day = datetime.datetime.today() + datetime.timedelta(days=1)
        return day.strftime ('%d-%m-%Y')

    def validate_num_people_res(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
        )-> Optional[Text]:

        if self.is_int(value) and int(value) > 0:
            return {"num_people_res": value}
        else:
            dispatcher.utter_template("utter_wrong_num_people_res", tracker)
            return {"num_people_res": None}
    
    def validate_time(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> Optional[Text]:
        if any(tracker.get_latest_entity_values("time")):
            switcher = {
                'ng√†y_mai':self.show_date(1),
                'ng√†y_kia':self.show_date(2),
                'h√¥m_nay':self.show_date(0)
            }
            value = switcher.get(value, value)
            return {"time": value}
        else:
            wrong_time = "!!!ü•¥ H√£y nh·∫≠p th·ªùi gian c·ª• th·ªÉ: \n\n\n Ex: ng√†y mai, ng√†y kia, ng√†y 09/01,..."
            buttons = [
                {
                    "title":"Ng√†y mai",
                    "payload":"ng√†y mai"
                },
                {
                    "title":"Ng√†y kia",
                    "payload":"ng√†y kia"
                },
                {
                    "title":"H√¥m nay",
                    "payload":"h√¥m nay"
                }

            ]
            dispatcher.utter_button_message(wrong_time, buttons=buttons)
            return {"time": None}

    def validate_phone_res(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> Optional[Text]:
        
        import re

        pattern = "^(0)[0-9]{9}"
        z = re.match(pattern, value)
    
        if z and len(value) == 10:
            return {"phone_res": value}
        else:
            dispatcher.utter_template("utter_wrong_phone", tracker)
            return {"phone_res": None}
            

    def submit(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> List[Dict]:

        msg = "ƒêang thi·∫øt l·∫≠p..."		
        dispatcher.utter_message(msg)
        dispatcher.utter_template("utter_confirm_res", tracker)
        return []

class ConfirmTransactionRestaurant(Action):
    def name(self) -> Text:
        return "action_confirm_restaurant"

    def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
        ) -> List[Dict]:
        msg1 = "ƒêang th·ª±c hi·ªán giao d·ªãch..."
        dispatcher.utter_message(msg1)
        msg2 = "‚úî ƒê√£ ƒë·∫∑t ch·ªó th√†nh c√¥ng!\
                \nTrong v√≤ng 5p s·∫Ω c√≥ nh√¢n vi√™n li√™n h·ªá v·ªõi b·∫°n."
        dispatcher.utter_message(msg2)
        return []

    ##edit form hottel 

class FormEditRestaurant(FormAction):
    def name(self):
        return "form_edit_res"

    @staticmethod
    def required_slots(tracker: Tracker) -> List[Text]:
        if tracker.get_slot("edit_inform_res") == "s·ªë ng∆∞·ªùi":
            return ["edit_num_people_res"]
        elif tracker.get_slot("edit_inform_res") == "sdt":
            return ["edit_phone_res"]
        elif tracker.get_slot("edit_inform_res") == "time":
            return ["edit_time"]
        else:
            return ["edit_add_request_res"]

    def slot_mappings(self) -> Dict[Text, Union[Dict, List[Dict]]]:

        return {
            "edit_num_people_res": [
                self.from_entity(entity="num_people_res"),
                self.from_text(),
            ],
            "edit_phone_res": self.from_text(),
            "edit_add_request_res": [
                self.from_text(),
            ],
            "edit_time:":[
                self.from_text(),
                self.from_entity(entity="time")
            ]
        }

    @staticmethod
    def is_int(string: Text) -> bool:
        """Check if a string is an integer"""
    
        try:
            int(string)
            return True
        except ValueError:
            return False
    
    def show_date(self,n):
        day = datetime.datetime.today() + datetime.timedelta(days=1)
        return day.strftime ('%d-%m-%Y')

    def validate_edit_time(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> Optional[Text]:
        if any(tracker.get_latest_entity_values("time")):
            switcher = {
                'ng√†y_mai':self.show_date(1),
                'ng√†y_kia':self.show_date(2),
                'h√¥m_nay':self.show_date(0)
            }
            value = switcher.get(value, value)
            return {"edit_time": value}
        else:
            wrong_time = "!!!ü•¥ H√£y nh·∫≠p th·ªùi gian c·ª• th·ªÉ: \n\n\n Ex: ng√†y mai, ng√†y kia, ng√†y 09/01,..."
            dispatcher.utter_message(wrong_time)
            return {"edit_time": None}

    def validate_edit_num_people_res(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
        )-> Optional[Text]:

        if self.is_int(value) and int(value) > 0:
            return {"edit_num_people_res": value}
        else:
            dispatcher.utter_template("utter_wrong_num_people_res", tracker)
            return {"edit_num_people_res": None}

    def validate_edit_phone_res(
        self,
        value: Text,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> Optional[Text]:

        pattern = "^(0)[0-9]{9}"
        z = re.match(pattern, value)
    
        if z and len(value) == 10:
            return {"edit_phone_res": value}
        else:
            dispatcher.utter_template("utter_wrong_phone", tracker)
            return {"edit_phone_res": None}

    def submit(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> List[Dict]:

        msg = "Thay ƒë·ªïi c·ªßa b·∫°n ƒë√£ ƒëc l∆∞u l·∫°i..."
        dispatcher.utter_message(msg)

        if tracker.get_slot("edit_inform_res") == "s·ªë ng∆∞·ªùi":
            value = tracker.get_slot("edit_num_people_res")
            return [SlotSet("num_people_res", value)]
        elif tracker.get_slot("edit_inform_res") == "sdt":
            value = tracker.get_slot("edit_phone_res")
            return [SlotSet("phone_res", value)]
        elif tracker.get_slot("edit_time") == "time":
            value = tracker.get_slot("edit_time")
            return [SlotSet("time", value)]
        else:
            value = tracker.get_slot("edit_add_request_res")
            return [SlotSet("add_request_res", value)]

class RestarFormEditRes(Action):
    def name(self) -> Text:
        return "restart_form_edit_res"

    def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
        ) -> List[Dict]:

        return [SlotSet("edit_inform_res", None),
                SlotSet("edit_num_people_res", None),
                SlotSet("edit_inform_res", None),
                SlotSet("edit_add_request_res", None)]

class ActionRestart(Action):
	def name(self)-> Text:
		return "action_restart"

	def run(self,
	   dispatcher: CollectingDispatcher,
	   tracker: Tracker,
	   domain: Dict[Text, Any]
	) -> List[Dict[Text, Any]]:
		return[Restarted()]

class ActionTestDB(Action):
    def name(self)-> Text:
        return "action_test"

    def run(self,
       dispatcher: CollectingDispatcher,
       tracker: Tracker,
       domain: Dict[Text, Any]
    ) -> List[Dict[Text, Any]]:      
    
        mydb = mysql.connector.connect(
           host="localhost",
           user="root",
           passwd="",
           database="chatbot",
           auth_plugin='mysql_native_password'
         )
        sqlht = 'select question from chatbot'
        mycursor = mydb.cursor()
        mycursor.execute(sqlht)
        myresult = mycursor.fetchall()  
        for x in myresult:
            dispatcher.utter_message(x)
        return[]

class ActioncolectDB(Action):
    def name(self)-> Text:
        return "action_collectdb"

    def run(self,
       dispatcher: CollectingDispatcher,
       tracker: Tracker,
       domain: Dict[Text, Any]
    ) -> List[Dict[Text, Any]]:
        dictmes = tracker.latest_message
        mes = dictmes['text']
        intent = dictmes['intent']['name']
        conn = sqlite3.connect('/media/baongocst/Free/sqlite3/test_nlu.db')
        c = conn.cursor()
        sql = "insert into chatbot(questions, intent) values('%s','%s')"%(mes, intent)
        c.execute(sql)
        conn.commit()
        c.close()
        conn.close()
        return[]


